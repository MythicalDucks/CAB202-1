%!TEX TS-program = xelatex
%!TEX options = -aux-directory=Debug -shell-escape -file-line-error -interaction=nonstopmode -halt-on-error -synctex=1 "%DOC%"
\documentclass{article}
\input{LaTeX-Submodule/template.tex}

% Additional packages & macros
\usepackage{xcolor}
\newcommand{\keyword}[1]{\textcolor[rgb]{0.00,0.50,0.00}{\textbf{#1}}}

\setminted{
    escapeinside=||
}

\usepackage{subcaption}
\usepackage{multicol}

% Header and footer
\newcommand{\unitName}{Microprocessors and Digital Systems}
\newcommand{\unitTime}{Semester 2, 2022}
\newcommand{\unitCoordinator}{Dr Mark Broadmeadow}
\newcommand{\documentAuthors}{Tarang Janawalkar}

\fancyhead[L]{\unitName}
\fancyhead[R]{\leftmark}
\fancyfoot[C]{\thepage}

% Copyright
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={4.0},
    imagewidth={5em},
    hyphenation={raggedright}
]{doclicense}

\date{}

\begin{document}
%
\begin{titlepage}
    \vspace*{\fill}
    \begin{center}
        \LARGE{\textbf{\unitName}} \\[0.1in]
        \normalsize{\unitTime} \\[0.2in]
        \normalsize\textit{\unitCoordinator} \\[0.2in]
        \documentAuthors
    \end{center}
    \vspace*{\fill}
    \doclicenseThis
    \thispagestyle{empty}
\end{titlepage}
\newpage
%
\tableofcontents
\newpage
%
\section{Microcontroller Fundamentals}
\subsection{Architecture of a Computer}
\begin{definition}[Computer]
    A computer is a digital electronic machine that can be programmed to carry
    out sequences of arithmetic or logical operations (computation) automatically.
\end{definition}
\begin{definition}[Control unit]
    The control unit interprets the instructions and decides what actions to take.
\end{definition}
\begin{definition}[Arithmetic logic unit]
    The arithmetic logic unit (ALU) performs computations required by the control unit.
\end{definition}
\subsection{Microprocessors \& Microcontrollers}
While a microcontroller puts the CPU and all peripherals onto the same chip,
a microprocessor houses a more powerful CPU on a single chip that connects to external peripherals.
The peripherals include memory, I/O, and control units.

The QUTy uses a microcontroller called ATtiny1626, that are within a family of microcontrollers called AVRs.
\subsection{ATtiny1626 Microcontroller}
The ATtiny1626 microcontroller has the following features:
\begin{itemize}
    \item CPU:\@ AVR Core (AVRxt variant)
    \item Memory:\@
          \begin{itemize}
              \item Flash memory (16KB) used to store program instructions in memory
              \item SRAM (2KB) used to store data in memory
              \item EEPROM (256B)
          \end{itemize}
    \item Peripherals:\@ Implemented in hardware (part of the chip) in order to offload complexity
\end{itemize}
\subsubsection{Flash Memory}
\begin{itemize}
    \item Non-volatile --- memory is not lost when power is removed
    \item Inexpensive
    \item Slower than SRAM
    \item Can only erase in large chunks
    \item Typically used to store programme data
    \item Generally read-only. Programmed via an external tool, which is loaded once and remains static during the lifetime of the program
    \item Writing is slow
\end{itemize}
\subsubsection{SRAM}
\begin{itemize}
    \item Volatile --- memory is lost when power is removed
    \item Expensive
    \item Faster than flash memory and is used to store variables and temporary data
    \item Can access individual bytes (large chunk erases are not required)
\end{itemize}
\subsubsection{EEPROM}
\begin{itemize}
    \item Older technology
    \item Expensive
    \item Non-volatile
    \item Can erase individual bytes
\end{itemize}
\subsection{AVR Core}
\begin{definition}[Computer programme]
    A computer programme is a sequence or set of instructions in a programming language
    for a computer to execute.
\end{definition}
The main function of the AVR Core Central Processing Unit (CPU) is to ensure correct program execution.
The CPU must, therefore, be able to access memory, perform calculations, control peripherals, and handle interrupts.
Some key characteristics of the AVR Core are:
\begin{itemize}
    \item 8-bit Reduced Instruction Set Computer (RISC)
    \item 32 working registers (R0 to R31)
    \item Program Counter (PC) --- location in memory where the program is stored
    \item Status Register (SREG) --- stores key information from calculations performed by the ALU (i.e., whether a result is negative)
    \item Stack Pointer --- temporary data that doesn't fit into the registers
    \item 8-bit core --- all data, registers, and operations, operate within 8-bits
\end{itemize}
\subsection{Programme Execution}
At the time of reset, PC = 0. The following steps are then performed:
\begin{enumerate}
    \item Fetch instruction (from memory)
    \item Decode instruction (decode binary instruction)
    \item Execute instruction:
          \begin{itemize}
              \item Execute an operation
              \item Store data in data memory, the ALU, a register, or update the stack pointer
          \end{itemize}
    \item Store result
    \item Update PC (move to next instruction or if instruction is longer than 1 word, increment twice. The program can also move to another point in the program that has an address \(k\), through jumps.)
\end{enumerate}
This is illustrated in the following figure:
\begin{figure}[H]
    \centering
    \includegraphics[height = 12cm, keepaspectratio = true]{figures/AVR_CPU.pdf}
    % \caption{} % \label{}
\end{figure}
\subsection{Instructions}
\begin{itemize}
    \item The CPU understands and can execute a limited set of instructions --- \textasciitilde88 unique instructions for the ATtiny1626
    \item Instructions are encoded in programme memory as opcodes. Most instructions are two bytes long, but some instructions are four bytes long
    \item The AVR Instruction Set Manual describes all of the available instructions, and how they are translated into opcodes
    \item Instructions fall loosely into five categories:
          \begin{itemize}
              \item Arithmetic and logic --- ALU
              \item Change of flow --- jumping to different sections of the code or making decisions
              \item Data transfer --- moving data in/out of registers, into the data space, or into RAM
              \item Bit and bit-test --- looking at data in registers (which bits are set or not set)
              \item Control --- changing what the CPU is doing
          \end{itemize}
\end{itemize}
\subsection{Interacting with memory and peripherals}
\begin{itemize}
    \item The CPU interacts with both memory and peripherals via the data space
    \item From the perspective of the CPU, the data space is single large array of
          locations that can be read from, or written to, using an address
    \item We control peripherals by reading from, and writing to, their registers
    \item Each peripheral register is assigned a unique address in the data space
    \item When a peripheral is accessed in this manner we refer to it as being
          memory mapped, as we access them as if they were normal memory
    \item Different devices, peripherals and memory can be included in a memory map
          (and sometimes a device can be accessed at multiple different addresses)
\end{itemize}
\subsection{Memory map}
\begin{figure}[H]
    \centering
    \includegraphics[height = 8cm, keepaspectratio = true]{figures/memory_map.pdf}
    % \caption{Memory map.} % \label{}
\end{figure}
\subsection{Assembly code}
\begin{itemize}
    \item The opcodes placed into programme memory are called
          machine code (i.e., code the machine operates on directly)
    \item We don't write machine code directly as it is:
          \begin{itemize}
              \item Not human readable
              \item Prone to errors (swapping a single bit can completely change the operation)
          \end{itemize}
    \item Instead we can write instructions directly in assembly code
    \item We use instruction mnemonics to specify each instruction:\@ \mintinline{ca65}{|\keyword{ldi}|}, \mintinline{ca65}{|\keyword{add}|}, \mintinline{ca65}{|\keyword{sts}|}, \mintinline{ca65}{jmp}, \dots
    \item An assembler takes assembly code and translates it into opcodes that can
          be loaded into programme memory
\end{itemize}
\section{Digital Representations and Operations}
\subsection{Digital Systems}
A \textbf{bit}\footnote{The term \textit{bit} comes from \textbf{b}inary dig\textbf{it}.}
is the most basic unit of information in a digital system.
A bit encodes a logical state with one of two possible values (i.e., binary).
These states are often referred to as:
\begin{itemize}
    \item true, false
    \item high, low (voltage states)
    \item on, off (logical states)
    \item set, reset
    \item 1, 0
\end{itemize}
A sequence of \textit{eight} bits is known as a \textbf{byte}, and it is the most
common representation of data in digital systems.
A sequence of \textit{four} bits is known as a \textbf{nibble}.

A sequence of \(n\) bits can represent up to \(2^n\) states.
\subsection{Representation}
\subsubsection{Binary Representation}
The \textbf{binary system} is a base-2 system that uses a sequence of bits to represent a number.
Bits are written left-to-right from \textbf{most significant} to \textbf{least significant} bit.

The first bit is the ``most significant'' bit because it is associated with the highest value in the sequence (coefficient of the highest power of two).
\begin{itemize}
    \item The \textbf{least significant bit} (LSB) is at bit index 0.
    \item The \textbf{most significant bit} (MSB) is at bit index \(n - 1\) in an \(n\)-bit sequence.
\end{itemize}
\begin{align*}
    0000_2 & = 0 & 0100_2 & = 4 & 1000_2 & = 8  & 1100_2 = 12 \\
    0001_2 & = 1 & 0101_2 & = 5 & 1001_2 & = 9  & 1101_2 = 13 \\
    0010_2 & = 2 & 0110_2 & = 6 & 1010_2 & = 10 & 1110_2 = 14 \\
    0011_2 & = 3 & 0111_2 & = 7 & 1011_2 & = 11 & 1111_2 = 15
\end{align*}
The subscript 2 indicates that the number is represented using a base-2 system.
\subsubsection{Hexadecimal Representation}
The \textbf{hexadecimal system} (hex) is a base-16 system. As we need 16 digits in this system, we use the letters A to F to represent digits 10 to 15.

Hex is a convenient notation when working with digital systems as each hex digit maps to a nibble.
\begin{align*}
    0_{16} & = 0000_2 & 4_{16} & = 0100_2 & 8_{16} & = 1000_2 & C_{16} = 1100_2 \\
    1_{16} & = 0001_2 & 5_{16} & = 0101_2 & 9_{16} & = 1001_2 & D_{16} = 1101_2 \\
    2_{16} & = 0010_2 & 6_{16} & = 0110_2 & A_{16} & = 1010_2 & E_{16} = 1110_2 \\
    3_{16} & = 0011_2 & 7_{16} & = 0111_2 & B_{16} & = 1011_2 & F_{16} = 1111_2
\end{align*}
\subsubsection{Numeric Literals}
When a fixed value is declared directly in a program, it is referred to as a \textbf{literal}.
Generally, numeric literals can be expressed as either binary, decimal, or hexadecimal, so we
use prefixes to denote various bases. Typically,
\begin{itemize}
    \item \textbf{Binary} notation requires the prefix \mintinline{ca65}{0b}
    \item \textbf{Decimal} notation does not require prefixes
    \item \textbf{Hexadecimal} notation requires the prefix \mintinline{ca65}{0x}
\end{itemize}
For example, \mintinline{ca65}{0x80 |=| 0b10000000 |=| 128}.
\subsection{Unsigned Integers}
The \textbf{unsigned integers} represent the set of counting (natural) numbers, starting at 0.
In the \textbf{decimal system} (base-10), the unsigned integers are encoded using a sequence of decimal digits (0--9).

The decimal system is a \textbf{positional numeral system}, where the contribution of each digit is determined by its position.
For example,
\begin{align*}
    278_{10} & = 2 \times 10^2 &  & + 7 \times 10^1 &  & + 8 \times 10^0 \\
             & = 2 \times 100  &  & + 7 \times 10   &  & + 8 \times 1    \\
             & = 200           &  & + 70            &  & + 8             \\
\end{align*}
In the \textbf{binary system} (base-2) the unsigned integers are encoded using a sequence of binary digits (0--1)
in the same manner. For example,
\begin{align*}
    10101_2 & = 1 \times 2^4 &  & + 0 \times 2^3 &  & + 1 \times 2^2 &  & + 0 \times 2^1 &  & + 1 \times 2^0 \\
            & = 1 \times 16  &  & + 0 \times 8   &  & + 1 \times 4   &  & + 0 \times 2   &  & + 1 \times 1   \\
            & = 16           &  & + 0            &  & + 4            &  & + 0            &  & + 1            \\
            & = 21_{10}
\end{align*}
The range of values an \(n\)-bit binary number can hold when encoding an unsigned integer is 0 to \(2^n - 1\).
\begin{table}[H]
    \centering
    \begin{tabular}{c c}
        \toprule
        \textbf{No.\ of Bits} & \textbf{Range}                        \\
        \midrule
        8                     & \(0\)--\(255\)                        \\
        16                    & \(0\)--\(\num{65535}\)                \\
        32                    & \(0\)--\(\num{4294967295}\)           \\
        64                    & \(0\)--\(\num{18446744073709551615}\) \\
        \bottomrule
    \end{tabular}
    \caption{Range of available values in binary representations.} % \label{}
\end{table}
\subsection{Signed Integers}
Signed integers are used to represent integers that can be positive or negative.
The following representations allow us to encode negative integers using a sequence of binary bits:
\begin{itemize}
    \item Sign-magnitude
    \item One's complement
    \item Two's complement (most common)
\end{itemize}
\subsubsection{Sign-Magnitude}
In sign-magnitude representation, the most significant bit encodes the sign of the
integer. In an 8-bit sequence, the remaining 7-bits are used to
encode the value of the bit.
\begin{itemize}
    \item If the sign bit is 0, the remaining bits represent a positive value,
    \item If the sign bit is 1, the remaining bits represent a negative value.
\end{itemize}
As the sign bit consumes one bit from the sequence, the range of values that can be
represented by an \(n\)-bit sign-magnitude encoded bit sequence is:
\begin{equation*}
    -\left( 2^{n - 1} - 1 \right) \text{ to } 2^{n - 1} - 1
\end{equation*}
For 8-bit sequences, this range is: \(-127\) to \(127\).

However, there are some issues with this representation.
\begin{enumerate}
    \item There are two ways to represent zero: \mintinline{ca65}{0b10000000 |=| 0}, or \mintinline{ca65}{0b00000000 |=| -0}.
    \item Arithmetic and comparison requires inspecting the sign bit
    \item The range is reduced by 1 (due to the redundant zero representation)
\end{enumerate}
\subsubsection{One's Complement}
In one's complement representation, a negative number is represented by
inverting the bits of a positive number (i.e., \(0 \to 1\) and \(1 \to 0\)).

The range of values are still the same:
\begin{equation*}
    -\left( 2^{n - 1} - 1 \right) \text{ to } 2^{n - 1} - 1
\end{equation*}
however, this representation tackles the second problem in the previous representation as
addition is performed via standard binary addition with \textit{end-around carry} (carry bit is added onto result).
\begin{equation*}
    a - b = a + \left( \text{\textasciitilde} b \right) + C.
\end{equation*}
\subsubsection{Two's Complement}
In two's complement representation, the most significant bit encodes a negative weighting of
\(-2^{n - 1}\). For example, in 8-bit sequences, index-7 represents a value of \(-128\).

The two's complement is calculated by adding 1 to the one's complement.

The range of values are:
\begin{equation*}
    -2^{n - 1} \text{ to } 2^{n - 1} - 1
\end{equation*}
This representation is more efficient than the previous because \mintinline{ca65}{0} has a single representation
and subtraction is performed by adding the two's complement of the subtrahend.
\begin{equation*}
    a - b = a + \left( \text{\textasciitilde} b + 1 \right).
\end{equation*}
\subsection{Logical Operators}
\subsubsection{Boolean Functions}
A Boolean function is a function whose arguments and results assume values
from a two-element set, (usually \(\left\{ 0,\: 1 \right\}\) or \mintinline{text}{{false, true}}).

These functions are also referred to as \textit{logical functions} when they operate on bits.
The most common logical functions available to microprocessors and most programming languages are:
\begin{itemize}
    \item Negation: \mintinline{ca65}{|\keyword{NOT}|}
    \item Conjunction: \mintinline{ca65}{AND}
    \item Disjunction: \mintinline{ca65}{|\keyword{OR}|}
    \item Exclusive disjunction: \mintinline{ca65}{|\keyword{XOR}|}
\end{itemize}
By convention, we map a bit value of \mintinline{ca65}{0} to \mintinline{ca65}{false}, and a bit value of \mintinline{ca65}{1} to \mintinline{ca65}{true}.
\subsubsection{Negation}
\mintinline{ca65}{NOT} is a unary operator that is used to \textbf{invert} a bit.
It is typically expressed as:
\begin{itemize}
    \item \mintinline{ca65}{|\keyword{NOT}|} \(a\)
    \item \textasciitilde\(a\)
    \item \(\overline{a}\)
\end{itemize}
Truth table:
\begin{table}[H]
    \centering
    \begin{tabular}{c c}
        \toprule
        \textbf{\(a\)} & \mintinline{ca65}{|\keyword{NOT}|} \(a\) \\
        \midrule
        0              & 1                                        \\
        1              & 0                                        \\
        \bottomrule
    \end{tabular}
\end{table}
\subsubsection{Conjunction}
\mintinline{ca65}{AND} is a binary operator whose output is true if \textbf{both} inputs are \textbf{true}.
It is typically expressed as:
\begin{itemize}
    \item \(a\) \mintinline{ca65}{AND} \(b\)
    \item \(a\) \mintinline{ca65}{&} \(b\)
    \item \(a \cdot b\)
    \item \(a \land b\)
\end{itemize}
Truth table:
\begin{table}[H]
    \centering
    \begin{tabular}{c c c}
        \toprule
        \textbf{\(a\)} & \textbf{\(b\)} & \textbf{\(a\) \mintinline{ca65}{AND} \(b\)} \\
        \midrule
        0              & 0              & 0                                           \\
        0              & 1              & 0                                           \\
        1              & 0              & 0                                           \\
        1              & 1              & 1                                           \\
        \bottomrule
    \end{tabular}
\end{table}
\subsubsection{Disjunction}
\mintinline{ca65}{|\keyword{OR}|} is a binary operator whose output is true if \textbf{either} input is \textbf{true}.
It is typically expressed as:
\begin{itemize}
    \item \(a\) \mintinline{ca65}{|\keyword{OR}|} \(b\)
    \item \(a\) \mintinline{ca65}{|\vert|} \(b\)
    \item \(a + b\)
    \item \(a \lor b\)
\end{itemize}
Truth table:
\begin{table}[H]
    \centering
    \begin{tabular}{c c c}
        \toprule
        \textbf{\(a\)} & \textbf{\(b\)} & \(a\) \mintinline{ca65}{|\keyword{OR}|} \(b\) \\
        \midrule
        0              & 0              & 0                                             \\
        0              & 1              & 0                                             \\
        1              & 0              & 1                                             \\
        1              & 1              & 1                                             \\
        \bottomrule
    \end{tabular}
\end{table}
\subsubsection{Exclusive Disjunction}
\mintinline{ca65}{|\keyword{XOR}|} (Exclusive \mintinline{ca65}{|\keyword{OR}|}) is a binary operator whose output is true if \textbf{only one} input is \textbf{true}.
It is typically expressed as:
\begin{itemize}
    \item \(a\) \mintinline{ca65}{|\keyword{XOR}|} \(b\)
    \item \(a\) \mintinline{ca65}{^} \(b\)
    \item \(a \oplus b\)
\end{itemize}
Truth table:
\begin{table}[H]
    \centering
    \begin{tabular}{c c c}
        \toprule
        \textbf{\(a\)} & \textbf{\(b\)} & \(a\) \mintinline{ca65}{|\keyword{XOR}|} \(b\) \\
        \midrule
        0              & 0              & 0                                              \\
        0              & 1              & 1                                              \\
        1              & 0              & 1                                              \\
        1              & 1              & 0                                              \\
        \bottomrule
    \end{tabular}
\end{table}
\subsubsection{Bitwise Operations}
When applying logical operators to a sequence of bits, the operation is performed in a \textbf{bitwise} manner. The result of each operation is stored in the corresponding bit index also.
\subsection{Bit Manipulation}
Often we need to modify individual bits within a byte, \textbf{without} modifying other bits.
This is accomplished by performing a bitwise operation on the byte using a \textbf{bit mask} or \textbf{bit field}.

These operations can:
\begin{itemize}
    \item \textbf{Set} specific bits (change value to \mintinline{ca65}{1})
    \item \textbf{Clear} specific bits (change value to \mintinline{ca65}{0})
    \item \textbf{Toggle} specific bits (change values from \(0 \to 1\), or \(1 \to 0\))
\end{itemize}
\subsubsection{Setting Bits}
To \textbf{set} a bit, we take the bitwise \mintinline{ca65}{|\keyword{OR}|} of the byte, with a bit mask
that has a \textbf{1} in each position where the bit should be set.
\begin{figure}[H]
    \centering
    \includegraphics[height = 4cm, keepaspectratio = true]{figures/bit_set.pdf}
    \caption{Setting bits using the logical or.} % \label{}
\end{figure}
\subsubsection{Clearing Bits}
To \textbf{clear} a bit, we take the bitwise \mintinline{ca65}{AND} of the byte, with a bit mask
that has a \textbf{0} in each position where the bit should be cleared.
\begin{figure}[H]
    \centering
    \includegraphics[height = 4cm, keepaspectratio = true]{figures/bit_clear.pdf}
    \caption{Clearing bits using the logical and.} % \label{}
\end{figure}
\subsubsection{Toggling Bits}
To \textbf{toggle} a bit, we take the bitwise \mintinline{ca65}{|\keyword{XOR}|} of the byte, with a bit mask
that has a \textbf{1} in each position where the bit should be toggled.
\begin{figure}[H]
    \centering
    \includegraphics[height = 4cm, keepaspectratio = true]{figures/bit_toggle.pdf}
    \caption{Toggling bits using the logical exclusive or.} % \label{}
\end{figure}
Other bitwise operations act on the entire byte.
\begin{itemize}
    \item One's complement (bitwise \mintinline{ca65}{|\keyword{NOT}|})
    \item Two's complement (bitwise \mintinline{ca65}{|\keyword{NOT}|} + 1)
    \item Shifts
          \begin{itemize}
              \item Logical
              \item Arithmetic (for signed integers)
          \end{itemize}
    \item Rotations
\end{itemize}
\subsubsection{One's Complement}
The one's complement of a byte inverts every bit in the operand. This is done by
taking the bitwise \mintinline{ca65}{|\keyword{NOT}|} of the byte.

Similarly, we can subtract the byte from \mintinline{ca65}{0xFF} to get the one's complement.
\subsubsection{Two's Complement}
The two's complement of a byte is the one's complement of the byte plus one.
Therefore, we can apply take the bitwise \mintinline{ca65}{|\keyword{NOT}|} of the byte, and then add one to it.
\subsubsection{Shifts}
Shifts are used to move bits within a byte. In many programming languages this is represented by two greater than \mintinline{ca65}{>>} or two less than \mintinline{ca65}{<<} characters.
\begin{equation*}
    a \gg s
\end{equation*}
shifts the bits in \(a\) by \(s\) places to the right while adding \mintinline{ca65}{0}'s to the MSB.\
\begin{figure}[H]
    \centering
    \includegraphics[height = 2cm, keepaspectratio = true]{figures/logical_right_shift.pdf}
    \caption{Right shift using \mintinline{ca65}{lsr} in AVR Assembly.} % \label{}
\end{figure}
Similarly
\begin{equation*}
    a \ll s
\end{equation*}
shifts the bits in \(a\) by \(s\) places to the left while adding \mintinline{ca65}{0}'s to the LSB.\
\begin{figure}[H]
    \centering
    \includegraphics[height = 2cm, keepaspectratio = true]{figures/logical_left_shift.pdf}
    \caption{Left shift using \keyword{\ttfamily{lsl}} in AVR Assembly.} % \label{}
\end{figure}
When using signed integers, the arithmetic shift is used to preserve the value of the sign bit when shifting.
\begin{figure}[H]
    \centering
    \includegraphics[height = 2cm, keepaspectratio = true]{figures/arithmetic_right_shift.pdf}
    \caption{Arithmetic right shift using \keyword{\ttfamily{asr}} in AVR Assembly.} % \label{}
\end{figure}
Left shifts are used to multiply numbers by 2, whereas right shifts are used to divide numbers by 2 (with truncation).
\subsubsection{Rotations}
Rotatations are used to shift bits with a carry from the previous instruction.
\begin{figure}[H]
    \centering
    \includegraphics[height = 2cm, keepaspectratio = true]{figures/rotate_left.pdf}
    \caption{Rotate left using \mintinline{ca65}{rol} in AVR Assembly.} % \label{}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[height = 2cm, keepaspectratio = true]{figures/rotate_right.pdf}
    \caption{Rotate right using \mintinline{ca65}{ror} in AVR Assembly.} % \label{}
\end{figure}
Here the blue bit is carried from the previous instruction, and the carry bit is updated
to the value of the bit that was shifted out.
Rotations are used to perform multi-byte shifts and arithmetic operations.
\subsection{Arithmetic Operations}
\subsubsection{Addition}
Addition is performed using the same process as decimal addition except we only use two digits, 0 and 1.
\begin{enumerate}
    \item \mintinline{ca65}{0b0 + 0b0 = 0b0}
    \item \mintinline{ca65}{0b0 + 0b1 = 0b1}
    \item \mintinline{ca65}{0b1 + 0b1 = 0b10}
\end{enumerate}
When adding two 1's, we carry the result into the next bit position as we would with a 10 in decimal addition.
In AVR Assembly, we can use the \mintinline{ca65}{|\keyword{add}|} instruction to add two bytes. The following
example adds two bytes.
\begin{minted}{ca65}
; Accumulator
|\keyword{ldi}| r16, 0

; First number
|\keyword{ldi}| r17, 29
|\keyword{add}| r16, 17 ; R16 <- R16 + R17 = 0 + 29 = 29

; Second number
|\keyword{ldi}| r17, 118
|\keyword{add}| r16, 17 ; R16 <- R16 + R17 = 29 + 118 = 147
\end{minted}
Below is a graphical illustration of the above code.
\begin{figure}[H]
    \centering
    \includegraphics[height = 3cm, keepaspectratio = true]{figures/add.pdf}
    \caption{Overflow addition using \keyword{\ttfamily{add}} in AVR Assembly.} % \label{}
\end{figure}
\subsubsection{Overflows}
When the sum of two 8-bit numbers is greater than 8-bit (255), an \textbf{overflow} occurs.
Here we must utilise a second register to store the high byte so that the result is represented as
a 16-bit number.

To avoid loss of information, a \textbf{carry bit} is used to indicate when an overflow has occurred.
This carry bit can be added to the high byte in the event that an overflow occurs.
This is because the carry bit is 0 when the sum is less than 256, and 1 when the sum is greater than 255.

The following example shows how to use the \mintinline{ca65}{adc} instruction to carry the carry bit when an overflow occurs.
\begin{minted}{ca65}
; Low byte
|\keyword{ldi}| r30, 0
; High byte
|\keyword{ldi}| r31, 0

; Empty byte for adding carry bit
|\keyword{ldi}| r29, 0

; First number
|\keyword{ldi}| r16, 0b11111111
; Add to low byte
|\keyword{add}| r30, r16 ; R30 <- R30 + R16 = 0 + 255 = 255, C <- 0
; Add to high byte
adc r31, r29 ; R31 <- R31 + R29 + C = 0 + 0 + 0 = 0

; Second number
|\keyword{ldi}| r16, 0b00000001
; Add to low byte
|\keyword{add}| r30, r16 ; R30 <- R30 + R16 = 255 + 1 = 0, C <- 1
; Add to high byte
adc r31, r29 ; R31 <- R31 + R29 + C = 0 + 0 + 1 = 1
\end{minted}
Therefore the final result is: \mintinline{ca65}{R31|:|R30 |=| 0b00000001|:|0b00000001 |=| 256}.
Below is a graphical representation of the above code.
\begin{figure}[H]
    \centering
    \includegraphics[height = 6cm, keepaspectratio = true]{figures/adc.pdf}
    \caption{Overflow addition using \mintinline{ca65}{adc} in AVR Assembly.} % \label{}
\end{figure}
\subsubsection{Subtraction}
Subtraction is performed using the same process as binary addition, with the
subtrahend in two's complement form.
In the case of overflows, the carry bit is discarded.
\subsubsection{Multiplication}
Multiplication is understood as the sum of a set of partial products, similar to the process used in decimal multiplication.
Here each digit of the multiplier is multiplied to the multipicand and each partial product is added to the result.

Given an \(m\)-bit and an \(n\)-bit number, the product is at most \((m+n)\)-bits wide.
\begin{align*}
    13 \times 43 & = 00001101_2 \times 00101011_2                \\
                 & = \begin{aligned}[t]
                          &   & 00001101_2 &  & \times &  & 1_2      \\
                          & + & 00001101_2 &  & \times &  & 10_2     \\
                          & + & 00001101_2 &  & \times &  & 1000_2   \\
                          & + & 00001101_2 &  & \times &  & 100000_2
                     \end{aligned} \\
                 & = \begin{aligned}[t]
                          &   & 00001101_2  \\
                          & + & 00011010_2  \\
                          & + & 01101000_2  \\
                          & + & 110100000_2
                     \end{aligned}                          \\
                 & = 1000101111
\end{align*}
Using AVR assembly, we can use the \mintinline{ca65}{|\keyword{mul}|} instruction to perform multiplication.
\begin{minted}{ca65}
; First number
|\keyword{ldi}| r16, 13
; Second number
|\keyword{ldi}| r17, 43

; Multiply
|\keyword{mul}| r16, r17 ; R1:R0 <- 0b00000010:0b00101111 = 2:47
\end{minted}
The result is stored in the register pair \mintinline{text}{R1:R0}.
\subsubsection{Division}
Division, square roots and many other functions are very expensive to implement in hardware,
and thus are typically not found in conventional ALUs, but rather
implemented in software.

However, there are other techniques that can be used to implement division in hardware.
By representing the divisor in reciprocal form, we can try to represent the number as
the sum of powers of 2.

For example, the divisor \(6.4\) can be represented as:
\begin{equation*}
    \frac{1}{6.4} = \frac{10}{64} = 10 \times 2^{-6}
\end{equation*}
so that dividing an integer \(n\) by \(6.4\) is approximately equivalent to:
\begin{equation*}
    \frac{n}{6.4} \approx \left( n \times 10 \right) \gg 6
\end{equation*}
When the divisor is not exactly representable as a power of 2 we can use fractional exponents to represent the divisor, however this requires a floating point system implementation which is not provided on the AVR.
\section{Microcontroller Interfacing}
\subsection{Logic Levels}
\subsubsection{Discretisation}
The process of discretisation translates a continuous signal into a discrete signal (bits).
As an example, we can translate \textbf{voltage levels} on microcontroller pins into digital \textbf{logic levels}.
\subsubsection{Logic Levels}
For digital input/output (IO), conventionally:
\begin{itemize}
    \item The voltage level of the positive power supply represents a \textbf{logical 1}, or the \textbf{high state}, and
    \item \qty{0}{V} (ground) represents a \textbf{logical 0}, or the \textbf{low state}.
\end{itemize}
The QUTy is supplied \qty{3.3}{V} so that when a digital output is high,
the voltage present on the corresponding pin will be around \qty{3.3}{V}.
Because voltage is a continuous quantity, we must discretise the full range of voltages into logical levels using \textbf{thresholds}.
\begin{itemize}
    \item A voltage \textbf{above} the input \textbf{high threshold} \(t_H\) is considered \textbf{high}.
    \item A voltage \textbf{below} the input \textbf{low threshold} \(t_L\) is considered \textbf{low}.
\end{itemize}
The interpretation of a voltage between these states is determined by \textbf{hysteresis}.
\subsubsection{Hysteresis}
Hysteresis refers to the property of a system whose state is \textbf{dependent} on
its \textbf{history}. In electronic circuits, this avoids ambiguity in determining
the state of an input as it switches between voltage levels.
\begin{figure}[H]
    \centering
    \includegraphics[height = 5cm, keepaspectratio = true]{figures/hysteresis.pdf}
    \caption{Example of hysteresis.} % \label{}
\end{figure}
Given a transition:
\begin{itemize}
    \item If an input is currently in the \textbf{low state}, it has not transitioned to the \textbf{high state} until the voltage crosses the \textbf{high input voltage} threshold.
    \item If an input is currently in the \textbf{high state}, it has not transitioned to the \textbf{low state} until the voltage crosses the \textbf{low input voltage} threshold.
\end{itemize}
It is therefore always preferrable to drive a digital input to an unambiguous voltage level.
\subsection{Electrical Quantities}
\subsubsection{Voltage}
\textbf{Voltage} \(v\) measures the electrical \textit{potential difference} between two points in a circuit, measured in \textbf{Volts (\unit{V})}.
\begin{itemize}
    \item Voltage is measured across a circuit element, or between two points in a circuit, most commonly with respect to a \qty{0}{V} reference (ground).
    \item It represents the \textbf{potential} of the electrical system to do \textbf{work}.
\end{itemize}
\subsubsection{Current}
\textbf{Current} \(i\) measures the \textit{rate of flow of electrical charge} through a circuit, measured in \textbf{Amperes (\unit{A})}.
\begin{itemize}
    \item Current is measured through a circuit element.
\end{itemize}
\subsubsection{Power}
\textbf{Power} \(p\) is the rate of energy transferred per unit time, measured in \textbf{Watts (\unit{W})}.
Power can be determined through the equation
\begin{equation*}
    p = v i.
\end{equation*}
\subsubsection{Resistance}
\textbf{Resistance} \(R\) is a property of a material to \textit{resist the flow of current}, measured in \textbf{Ohms (\unit{\ohm})}.
Ohm's law states that the voltage across a component is proportional to the current that flows through it:
\begin{equation*}
    v = i R.
\end{equation*}
Note that not all circuit elements are resistive (or Ohmic), such that they
do not follow Ohm's law, this can be seen in diodes.
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.47\linewidth}
        \centering
        \includegraphics[height=4.5cm]{figures/vi_ohmic.pdf}
        \caption{VI curve for Ohmic components.}
    \end{subfigure}
    \begin{subfigure}{0.47\linewidth}
        \centering
        \includegraphics[height=4.5cm]{figures/vi_diode.pdf}
        \caption{VI curve for diodes.}
    \end{subfigure}
    \caption{Voltage-current characteristic curves for various components.}
\end{figure}
Although the wires used to connect a circuit are resistive, we usually assume that they are ideal, that is,
they have zero resistance.
\subsection{Electrical Components}
\subsubsection{Resistors}
A \textbf{resistor} is a circuit element that is designed to have a specific resistance \(R\).
\begin{figure}[H]
    \centering
    \includegraphics[height = 2.5cm, keepaspectratio = true]{figures/resistor.pdf}
    \caption{Resistor circuit symbol.} % \label{}
\end{figure}
\subsubsection{Switches}
A \textbf{switch} is used to connect and disconnect different elements in a circuit. It can be \textbf{open}
or \textbf{closed}.
\begin{itemize}
    \item In the \textbf{open} state, the switch \textbf{will not conduct}\footnote{Conductance is a measure of the ability for electric charge to flow in a certain path.} current
    \item In the \textbf{closed} state, the switch \textbf{will conduct} current
\end{itemize}
Switches can take a variety of forms:
\begin{itemize}
    \item \textbf{Poles} --- the number of circuits the switch can control.
    \item \textbf{Throw} --- the number of output connections each pole can connect its input to.
    \item Momentary or toggle action
    \item Different form factors, e.g., push button, slide, toggle, etc.
\end{itemize}
Switches are typically for user input.
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.47\linewidth}
        \centering
        \includegraphics[width=2.5cm]{figures/spst.pdf}
        \caption{Single pole single throw switch.}
    \end{subfigure}
    \begin{subfigure}{0.47\linewidth}
        \centering
        \includegraphics[width=2.5cm]{figures/spdt.pdf}
        \caption{Single pole double throw switch.}
    \end{subfigure}

    \vspace*{5ex}
    \begin{subfigure}{0.47\linewidth}
        \centering
        \includegraphics[width=2.5cm]{figures/dpst.pdf}
        \caption{Double pole single throw switch.}
    \end{subfigure}
    \begin{subfigure}{0.47\linewidth}
        \centering
        \includegraphics[width=2.5cm]{figures/dpdt.pdf}
        \caption{Double pole double throw switch.}
    \end{subfigure}
    \caption{Various types of switches.}
\end{figure}
\subsubsection{Diodes}
A \textbf{diode} is a semiconductor device that conducts current in
only one direction: from the \textbf{anode} to the \textbf{cathode}.
\begin{figure}[H]
    \centering
    \includegraphics[height = 2cm, keepaspectratio = true]{figures/diode.pdf}
    \caption{Diode symbol.} % \label{}
\end{figure}
Diodes are a non-Ohmic device:
\begin{itemize}
    \item When \textbf{forward biased}, a diode \textbf{does} conduct current, and the anode-cathode voltage
          is equal to the diodes \textbf{forward voltage}.
    \item When \textbf{reverse biased}, a diode \textbf{does not} conduct current, and the cathode-anode voltage
          is equal to the \textbf{applied voltage}.
\end{itemize}
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.47\linewidth}
        \centering
        \includegraphics[height=3.5cm]{figures/diode_forward_bias.pdf}
        \caption{Forward biased diode. \\\(v_{AK} = v_f\) and \(i > 0\).}
    \end{subfigure}
    \begin{subfigure}{0.47\linewidth}
        \centering
        \includegraphics[height=3.5cm]{figures/diode_reverse_bias.pdf}
        \caption{Reverse biased diode. \\\(v_{KA} > 0\) and \(i = 0\).}
    \end{subfigure}
    \caption{Diodes in forward and reverse bias.}
\end{figure}
A diode is only forward biased when the applied anode-cathode voltage \textbf{exceeds} the forward voltage \(v_f\).
A typical forward voltage \(v_f\) for a silicon diode is in the range \qtyrange{0.6}{0.7}{V}, whereas for
Light Emitting Diodes (LEDs), \(v_f\) ranges between \qtyrange{2}{3}{V}.
\subsubsection{Integrated Circuit}
An \textbf{integrated circuit} (IC) is a set of electronic circuits (typically) implemented on a
single piece of semiconductor material, usually silicon. ICs comprise of hundreds to
many thousands of transistors, resistors and capacitors; all implemented on silicon.
ICs are \textbf{packaged}, and connections to the internal circuitry are exposed via \textbf{pins}.

In general, the specific implementation of the IC is not important, but
rather the \textbf{function of the device} and how it \textbf{interfaces} with the rest of the circuit.
Hence ICs can be treated as a functional \textbf{black box}.

For digital ICs:
\begin{itemize}
    \item \textbf{Input pins} are typically \textbf{high-impedance}, and they appear as an open circuit.
    \item \textbf{Output pins} are typically \textbf{low-impedance}, and will actively drive the voltage
          on a pin and any connected circuitry to a \textbf{high} or \textbf{low} state. They can also
          drive connected loads.
\end{itemize}
\subsection{Digital Outputs}
Digital output interfaces are designed to be able to drive connected circuitry to one of states,
high, or low, however, the appropriate technique is \textbf{context specific}.
When referring to digital outputs, we will refer to the states of a net. A \textbf{net}
is defined as the common point of connection of multiple circuit components.

In this section we will consider:
\begin{itemize}
    \item What kind of load the output drives?
    \item Could more than one device be attempting to actively drive the net
          to a specific logic level?
\end{itemize}
\subsubsection{Push-Pull Outputs}
A push-pull digital output is the most common form of output used in digital outputs.
The \textbf{output driver} \(A\) \textit{drives} the \textbf{output state} \(Y\) to:
\begin{itemize}
    \item \textbf{HIGH} by connecting the output net to the supply voltage \(+\unit{V}\).
    \item \textbf{LOW} by connecting the output net to the ground voltage GND (\qty{0}{V}).
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[height = 4cm, keepaspectratio = true]{figures/push_pull.pdf}
    \caption{Push-pull output.} % \label{}
\end{figure}
Hence the output state \(Y\) is determined by the logic level of the output driver \(A\).
\begin{equation*}
    Y = A.
\end{equation*}
\begin{table}[H]
    \centering
    \begin{tabular}{c | c}
        \toprule
        \textbf{\(A\)} & \textbf{\(Y\)} \\
        \midrule
        LOW            & LOW            \\
        HIGH           & HIGH           \\
        \bottomrule
    \end{tabular}
    \caption{Truth table for a push-pull digital output.} % \label{}
\end{table}
The push-pull output \(Y\) can both source and sink current from the connected net.
\subsubsection{High-Impedance Outputs}
In many instances, a digital output is required to be placed in a high-impedance (HiZ) state.
This is accomplished by using an \textbf{output enable} (OE) signal.
\begin{figure}[H]
    \centering
    \includegraphics[height = 4cm, keepaspectratio = true]{figures/HiZ.pdf}
    \caption{High-impedance output.} % \label{}
\end{figure}
\begin{itemize}
    \item When the OE signal is \textbf{HIGH}, the output state \(Y\) is determined by the output driver \(A\).
    \item When the OE signal is \textbf{LOW}, the output state \(Y\) is in a \textbf{high-impedance} state.
\end{itemize}
\begin{table}[H]
    \centering
    \begin{tabular}{c c | c}
        \toprule
        \textbf{\(A\)} & \textbf{OE} & \textbf{\(Y\)} \\
        \midrule
        LOW            & LOW         & HiZ            \\
        HIGH           & LOW         & HiZ            \\
        LOW            & HIGH        & LOW            \\
        HIGH           & HIGH        & HIGH           \\
        \bottomrule
    \end{tabular}
    \caption{Truth table for a push-pull digital output.} % \label{}
\end{table}
When the output is in \textbf{HiZ state}:
\begin{itemize}
    \item The output is an effective \textbf{open circuit}, meaning it has \textbf{no effect} on the rest of the circuit.
    \item The voltage on the output net is determined by the \textbf{other circuitry} connected to the net.
\end{itemize}
HiZ outputs are typically used when multiple need to signal over the same wire(s).
\subsubsection{Pull-up and Pull-down Resistors}
When \textbf{no devices} are actively driving a net (e.g., all connected outputs are in the HiZ state),
the state of the net is not well-defined. Hence we can use a \textbf{pull-up} or \textbf{pull-down} resistor
to ensure that the state of the pin is always \textbf{well-defined}.
\begin{multicols}{2}
    \begin{figure}[H]
        \centering
        \includegraphics[height = 4cm, keepaspectratio = true]{figures/pullup_resistor.pdf}
        \caption{Pull-up resistor.} % \label{}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[height = 4cm, keepaspectratio = true]{figures/pulldown_resistor.pdf}
        \caption{Pull-down resistor.} % \label{}
    \end{figure}
\end{multicols}
\begin{itemize}
    \item When \textbf{no circuitry} is actively driving the net, the resistor will passively pull the voltage to either the voltage supply, or ground.
    \item When \textbf{another device} actively drives the net, the active device defines the voltage of the net. Hence the current from the resistor is simply sourced
    or sunk by the \textbf{active device}.
\end{itemize}
The resistors used as pull-up and pull-down resistors are typically in the \unit{k\ohm} range.
\subsubsection{Open-Drain Outputs}
Multiple push-pull outputs should never be connected to the same net
as when one output is driven HIGH and another is driven LOW,
an effective short circuit is created and one or more devices may be damaged.
While push-pull outputs with an output enable may be used,
the timing must be carefully managed.

Hence a more robust solution is to use open-drain outputs.
\begin{figure}[H]
    \centering
    \includegraphics[height = 4cm, keepaspectratio = true]{figures/open_drain.pdf}
    \caption{Open-drain output.} % \label{}
\end{figure}
An open-drain output is either:
\begin{itemize}
    \item In the \textbf{high-impedance} state, where the pull-up resistor is used to pull the net to the \textbf{high state} when the net is \textbf{not driven low}.
    \item \textbf{Connected to ground}, when the net is \textbf{driven low}.
\end{itemize}
\subsection{Microcontroller Pins}
Microcontrollers are interfaced via their exposed pins.
These pins are the only means to access inputs and outputs, and
they are used to interface with other electronic circuits in order to achieve a required functionality.
Pins can be used for:
\begin{itemize}
    \item General purpose input and output (GPIO) --- pin represents a digital state
    \item Peripheral functions
    \item Other functions (power supply, reset input, clock input, etc.)
\end{itemize}
Pins are typically organised into groups of related IO banks,
referred to as \textbf{ports} on the AVR microcontroller.

These ports and pins are assigned an alphanumeric identifier, (e.g., PB7 for pin 7 on port B).
\begin{figure}[H]
    \centering
    \includegraphics[height = 8cm, keepaspectratio = true]{figures/PORT_block_diagram.pdf}
    \caption{ATtiny1626 PORT block diagram.} % \label{}
\end{figure}
To summarise this diagram:
\begin{itemize}
    \item The data direction register (DIR) controls the push-pull output enable.
    \item The output driver register (OUT) drives the output state.
    \item The input register (IN) reads the output state.
    \item The internal pull-up register enabled through software.
    \item The physical voltage on the pin can be routed to an analogue to digital converter (ADC)
    \item Other peripheral functions can override port pin configurations and the output state.
\end{itemize}
\subsubsection{Configuring an Output in Assembly}
\begin{enumerate}
    \item Place the port pin in a \textbf{safe initial state}
    by writing to the OUT register (HIGH or LOW depending on the context).
    \item Configure the port pin as an output by \textbf{setting} the corresponding bits in the DIR register.
    \item Set the desired pin state by writing to the OUT register.
\end{enumerate}
\begin{minted}{ca65}
; Load macros for easy access to port data space addresses.
#include <avr/io.h>

; Bitmask for pin 5
|\keyword{ldi}| r16, PIN5_bm

; Set initial safe state
|\keyword{sts}| PORTB_OUTCLR, r16 ; LOW if active HIGH
|\keyword{sts}| PORTB_OUTSET, r16 ; HIGH if active LOW

; Enable output
|\keyword{sts}| PORTB_DIRSET, r16 ; Enable output on PB5

; Set output state to desired value
|\keyword{sts}| PORTB_OUTSET, r16 ; Set state of PB5 to HIGH
\end{minted}
\subsubsection{Configuring an Input in Assembly}
\begin{enumerate}
    \item If required, enable the internal pull-up resistor by \textbf{setting}
    the PULLUPEN bit in the \linebreak corresponding PINnCTRL register.
    \item Read the IN register to get the current state of the pin.
    \item Isolate the relevant pin using the AND operator.
\end{enumerate}
\begin{minted}{ca65}
; Load macros for easy access to port data space addresses.
#include <avr/io.h>

; Bitmask for pin 5
|\keyword{ldi}| r16, PIN5_bm

; Enable internal pull-up resistor if required
|\keyword{sts}| PORTB_PIN5CTRL, r16

; Read output state from data space
|\keyword{lds}| r17, PORTA_IN
; Read output state using virtual PORT
|\keyword{in}| r17, VPORTA_IN

; Isolate desired pin
|\keyword{andi}| r17, r16
\end{minted}
\subsubsection{Peripheral Multiplexing}
Pins can be used to connect internal peripheral functions
to external devices.
As microcontrollers have more peripheral functions than available pins,
peripheral functions are typically multiplexed onto pins.
\begin{definition}[Multiplexing]
    Multiplexing is a method by which \textbf{multiple peripheral} \linebreak \textbf{functions}
    are mapped to the \textbf{same pin}.
    In this scenario, only one function can be enabled at a time, and the pin
    cannot be used for GPIO\@.
\end{definition}
\begin{itemize}
    \item Peripheral functions can be mapped to different \textbf{sets of pins} to provide
    flexibility and to avoid clashes when multiple peripherals are used in
    an application.
    \item When enabled, peripheral functions \textbf{override} standard port functions.
    \item The \textbf{Port Multiplexer} (PORTMUX) is used to select which
    \textbf{pin set} should be used by a peripheral.
    \item Certain peripherals can have their inputs/outputs mapped to different
    \textbf{sets of pins} through the PORTMUX\@.
\end{itemize}
Note that we cannot re-map a single peripheral function to another pin, but must consider the entire set.
\subsection{Interfacing to Simple IO}
\subsubsection{Driving LEDs}
The \textbf{brightness} of an LED is proportional to the \textbf{current}
passing through it. As LEDs are non-Ohmic, we cannot drive them directly
with a voltage as this would result in an uncontrolled flow of current that
may damage the LED or driver.

Instead, LEDs are paired with a \textbf{series resistor} to limit the flow of current.
The appropriate current is dependent on the specific LED that is used
and the capability of the driver device (microcontroller).
A typical indictor LED requires a current of \qtyrange{1}{2}{mA}.
\subsubsection{Interfacing to LEDs}
An LED can be driven in two different configurations from a microcontroller pin:
\begin{itemize}
    \item \textbf{active high}; in which case the LED is \textbf{lit} when the pin is \textbf{HIGH}.
    \item \textbf{active low}; in which case the LED is \textbf{lit} when the pin is \textbf{LOW}.
\end{itemize}
Both of these configurations have their benefits, and the best configuration depends entirely on the context.
\pagebreak
\begin{multicols}{2}
    \begin{figure}[H]
        \centering
        \includegraphics[height = 4cm, keepaspectratio = true]{figures/active_high_LED.pdf}
        \caption{LED in an active high configuration.} % \label{}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[height = 4cm, keepaspectratio = true]{figures/active_low_LED.pdf}
        \caption{LED in an active low configuration.} % \label{}
    \end{figure}
\end{multicols}
On the QUTy, the LED display is driven in the \textbf{active low} configuration.
This has a number of advantages:
\begin{itemize}
    \item If the internal pull-up resistors are mistakenly enabled, no current will
    flow into the LEDs.
    \item The microcontroller pins can sink higher currents than they can source,
    allowing us to drive the display to a higher brightness.
    \item The display used on the QUTy has a common anode configuration, hence we must use an
    active low configuration to drive the display segments independently.
\end{itemize}
An LED is an example of a simple \textbf{digital output}, as we can map \textbf{logical states}
to \textbf{LED states} (lit or unlit) for a digital output.
\subsubsection{Switches as Digital Inputs}
The state of a switch can be used to \textbf{set} the state of a pin.
As the switch has two states (open or closed), these can be mapped directly to
\textbf{logical states}.

This can be done by connecting the switch between the pin and voltage source
representing one of the logic levels (ground or a positive supply).
\begin{multicols}{2}
    \begin{figure}[H]
        \centering
        \includegraphics[height = 5cm, keepaspectratio = true]{figures/active_high_switch.pdf}
        \caption{Switch in an active high \\ configuration.} % \label{}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[height = 5cm, keepaspectratio = true]{figures/active_low_switch.pdf}
        \caption{Switch in an active low configuration.} % \label{}
    \end{figure}
\end{multicols}
\begin{itemize}
    \item When the switch is \textbf{open}, the pull-up/pull-down resistor is used to define the state of the switch.
    \item When the switch is \textbf{closed}, the state of the pin is defined by the voltage connected to via the switch.
\end{itemize}
\subsubsection{Interfacing to Switches}
As with LEDs, we can interface switches to microcontroller pins in two different configurations:
\begin{itemize}
    \item \textbf{active high}; in which case the pin is \textbf{HIGH} when the switch is \textbf{closed}.
    \item \textbf{active low}; in which case the pin is \textbf{LOW} when the switch is \textbf{closed}.
\end{itemize}
An \textbf{active low} configuration is usually preferred as:
\begin{itemize}
    \item it allows for the utilisation of an \textbf{internal pull-up resistor} that is commonly
    implemented in microcontrollers.
    \item It eliminates the risk of unsafe voltages being applied to the pin from the power supply in an active high configuration.
    \item It is easier to access a ground reference on a circuit board.
\end{itemize}
\subsubsection{Interfacing to Integrated Circuits}
For digital ICs,
\begin{itemize}
    \item \textbf{Inputs} are typically \textbf{high impedance}
    \item \textbf{Outputs} are typically \textbf{push-pull}
\end{itemize}
This generally means that we can interface an IC by connecting its pins directly to the pins of a microcontroller.
\begin{itemize}
    \item For \textbf{IC inputs}, the microcontroller pin is configured as an \textbf{output},
    and the \textbf{microcontroller sets} the logic level of the net.
    \item For \textbf{IC outputs}, the microcontroller pin is configured as an \textbf{input},
    and the \textbf{IC sets} the logic level of the net.
\end{itemize}
As microcontroller pins are typically configured as \textbf{inputs on reset}, a
pull-up/pull-down resistor may be required if it is important for an IC input to
have a \textbf{known state} prior to the configuration of the relevant microcontroller pins as outputs.
\end{document}
